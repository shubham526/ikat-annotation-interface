# Annotation interface for response evaluation

## Description 
This is a web-based platform designed to facilitate the evaluation of responses generated by conversational AI systems. The application provides a user-friendly interface where authenticated users can view various conversations and rate them based on specific metrics. 

## System Architecture

### Backend

The backend of the system is built using the Flask micro web framework. It handles server-side logic, including:

- **User Authentication**: The backend manages user sessions, allowing users to log in, sign up, and log out.
- **Data Management**: The backend interacts with an SQLite database to fetch, store, and manage user evaluations of conversations.
- **Routing**: Flask routes determine what should happen when a user visits a particular URL. For instance, the `/login` route handles user login, while the `/evaluate` route processes user evaluations.
- **Template Rendering**: Flask uses the Jinja2 template engine to serve dynamic HTML templates. This allows the backend to generate web pages based on data from the database.

### Frontend

The frontend provides a user-friendly interface for evaluating conversations. It's built using:

- **HTML**: The structure of the web pages is defined using HTML. The provided code contains a main content area where conversations are displayed and a side pane that shows the evaluation rubric.
  
- **CSS**: The visual styling of the web pages is defined using CSS. The provided code uses Bootstrap, a popular CSS framework, to ensure a responsive and modern design. Custom styles are also defined to enhance the user interface.
  
- **JavaScript**: JavaScript is used to add interactivity to the web pages. The provided code uses jQuery, a popular JavaScript library, to handle user interactions like submitting evaluations. AJAX calls are made to the backend to send and retrieve data without reloading the page.
  
- **Bootstrap**: Bootstrap components and scripts are used to enhance the user interface and provide a responsive design. This ensures that the web application looks good on both desktop and mobile devices.

### Database Schema 
![image](https://drive.google.com/uc?export=view&id=1TVdOVcjuuE4YHg_nrXaX2OKAziiwMBbV)

The database is structured to capture and manage conversations, users, evaluations, and batches. At its core, the `conversations` table stores details of individual conversations, including context, turn ID, run ID, and responses. Users and their credentials are maintained in the `users` table. The `evaluations` table links users to conversations, recording evaluations on aspects like relevance, naturalness, and conciseness. Batches of conversations are managed through the `batches` table, with the `batch_conversations` table mapping which conversations belong to which batches. Additionally, the `batch_assignments` table facilitates a many-to-many relationship between users and batches, indicating which users are assigned to specific batches. This schema provides a comprehensive framework for tracking and evaluating conversations in batches, with the flexibility to assign batches to multiple users and gather evaluations seamlessly.


## Installation with Conda
### Prerequisites 
[Anaconda](https://www.anaconda.com/download) or [Miniconda](https://docs.conda.io/projects/miniconda/en/latest/)

### Steps 
Follow the steps below to run the code.

1. Clone this repository:
```
git clone https://github.com/shubham526/ikat-annotation-interface.git
cd ikat-annotation-interface
```
2. Create a new Conda environment and activate it:
```
conda create --name $env_name python=3.9
conda activate $env_name
```
where `$env_name` is the name of the Conda environment you wish to use. 

3. Install Flask:
```
conda install flask
```
4. Create the database:
```
python create_db.py --data PATH_TO_DATA
```
> **Note.** The script will attempt to read the data from a file specified with the `--data` path. See below how to create this file. It will create a database called `ikat-database.db`, in the same directory as this script. The app will expect the database to be present at this location.
5. Set the flask environment variable:
```
export FLASK_SECRET_KEY='your_secret_key_here'
```
> See below for more details on this secret key.
6. Run the application:
```
python app.py
```
## Usage
- Navigate to http://127.0.0.1:5000/ in your web browser.
- If you're a new user, sign up. Otherwise, log in.
- Browse through the conversations and submit your evaluations.

## Flask secret key

### What is the "secret key" in step #5 above? Why do I need it?
The "secret key" in step #5 above is used for Flask's session management. It's important to set a secret key for security reasons, especially when using sessions in your application. Session management is often used for features like user authentication, storing user-specific data, and maintaining the state of a user's interaction with a web application. The secret key is used to sign session cookies, which helps ensure the integrity and security of the data stored in the session. Without a secret key, session data could be tampered with or compromised, potentially leading to security vulnerabilities.

### How do I generate a secret key?
To generate a secret key, you can use the `secrets` module:
```python
import secrets
secret_key = secrets.token_hex(16)
```
This generates a 32-character hexadecimal key. You can adjust the length by changing the argument passed to `token_hex()`. You should store this key in a safe place and use it to set the environment variable as described above.

## Creating the data for evaluation using the interface
For iKAT 2023, we conducted a manual inspection of the topics and chose specific turns for response evaluation. From the submitted runs, we selected responses from 10 distinct runs. For every turn, the top response from each run was chosen for assessment. These selected turns were then mixed in a random order to form batches, with each batch containing 20 conversations. Our interface is configured to present each batch to a minimum of two users. Importantly, no individual user will be assigned more than two batches. However, after completing their assigned two batches, users will have the option to voluntarily annotate additional batches if they wish.

We provide [our script](https://github.com/shubham526/ikat-annotation-interface/blob/main/create_response_evaluation_data.py) to create the batched data. 

### Command-line arguments
- `--turns`: Specifies the path to the file containing the turns that are to be judged. This file should list the turn IDs that you wish to evaluate.
- `--topics`: Provides the path to the topics file. This file contains the details of the topics related to the turns.
- `--runs`: Indicates the directory where the run files to be evaluated are located. These files contain the responses for the turns based on different runs.
- `--save`: Designates the directory where the processed data will be saved. The script will generate batches of data and save them as JSON files in this directory.

### Run the script
```
python script_name.py --turns PATH_TO_TURNS_FILE --topics PATH_TO_TOPICS_FILE --runs PATH_TO_RUNS_DIRECTORY --save PATH_TO_SAVE_DIRECTORY
```

## Downloading the evaluation results
We provide a [script](https://github.com/shubham526/ikat-annotation-interface/blob/main/write_results_to_json.py) to fetch evaluation results from an SQLite database and organize them by users. The organized data is then written to a JSON file. 

### Command-line arguments
The script accepts two command-line arguments:
- `--database`: The path to the SQLite database file.
- `--save`: The path (including filename) where the organized data should be saved as a JSON file.

### Run the script
```
python write_results_to_json.py --database PATH_TO_DATABASE --save PATH_TO_SAVE_JSON
```

### Example JSON created by the script:
```
[
        {
                "user_id": "user1",
                "evaluations": [
                    {
                        "conversation_id": "R00635",
                        "relevance": 0,
                        "naturalness": 0,
                        "conciseness": 0
                    },
                    {
                        "conversation_id": "R00136",
                        "relevance": 3,
                        "naturalness": 1,
                        "conciseness": 1
                    },
                    {
                        "conversation_id": "R00394",
                        "relevance": 3,
                        "naturalness": 3,
                        "conciseness": 1
                    },
        },
        {
                "user_id": "user2",
                "evaluations": [
                    {
                        "conversation_id": "R00635",
                        "relevance": 1,
                        "naturalness": 0,
                        "conciseness": 2
                    },
                    {
                        "conversation_id": "R00136",
                        "relevance": 2,
                        "naturalness": 1,
                        "conciseness": 1
                    },
                    {
                        "conversation_id": "R00394",
                        "relevance": 2,
                        "naturalness": 2,
                        "conciseness": 1
                    },
        }
]
```



## Contributing
If you'd like to contribute, please fork the repository and make changes as you'd like. Pull requests are warmly welcome.

## License
This project is open-sourced under the MIT License. For details, see the license file. 

